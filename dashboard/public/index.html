<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shitflix Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/icons/favicon.png">
    <script src="https://unpkg.com/htmx.org"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="container">
    <h1>
        <img src="/icons/favicon.png" alt="Downloader icon"
             style="height: 1.2em;
             vertical-align: middle;
             margin-right: 0.2em;">
        Shitflix Dashboard
    </h1>

    <div class="service-buttons">
        <button onclick="openService(8096)" class="service-btn jellyfin-btn">
            üé¨ Jellyfin
        </button>
        <button onclick="openService(9091)" class="service-btn transmission-btn">
            ‚öôÔ∏è Transmission
        </button>
        <button id="wishlist-btn" class="service-btn wishlist-btn">
            üìù Wishlist
        </button>
        <button id="sync-btn" class="service-btn sync-btn">
            üîÑ Sync
        </button>

    </div>

    <div class="search-form">
        <form onsubmit="return false;">
            <div class="form-group">
                <label for="movie">Movie Name</label>
                <input type="text" id="movie" name="movie" placeholder="Enter movie name..."/>
            </div>

            <div class="form-group">
                <label for="extra">Extra Search Params</label>
                <input type="text" id="extra" name="extra" value="1080" placeholder="Quality, year, etc..."/>
            </div>

            <button class="search-btn"
                    hx-get="/get-search-results"
                    hx-trigger="click"
                    hx-swap="innerHTML"
                    hx-target="#search-results-container"
                    hx-indicator=".loading">
                üîç Search
            </button>
        </form>
    </div>

    <div id="download-result-container"></div>

    <div class="loading" style="display:none;">
        ‚è≥ Searching...
    </div>

    <div id="search-results-container">
        <!-- Results will be displayed here -->
    </div>
</div>

<div id="preloader-modal" class="modal">
    <div class="modal-content">
        <div class="modal-icon"></div>
    </div>
</div>

<div id="download-modal" class="modal">
    <div class="modal-content-dld">
        <div class="modal-form">
            <label for="download-location">Download Location:</label>
            <input type="text" id="download-location" value="/downloads/movies"/>
            <button id="confirm-download" class="confirm-btn">Start Download</button>
            <button id="cancel-download" class="cancel-btn">Cancel</button>
        </div>
    </div>
</div>
<div id="wishlist-modal" class="modal">
    <div class="wishlist-modal-content">
        <div class="wishlist-header">
            <h2>üìù Movie Wishlist</h2>
            <button class="close-wishlist-btn">&times;</button>
        </div>
        <div class="wishlist-add-section">
            <div class="add-form-row">
                <select id="add-type" class="add-input">
                    <option value="m">üé¨ Movie</option>
                    <option value="s">üì∫ Series</option>
                </select>
                <input type="text" id="add-name" class="add-input" placeholder="Movie.Name.Here">
                <input type="text" id="add-quality" class="add-input add-quality" placeholder="1080" value="1080">
                <button id="add-wishlist-btn" class="add-btn">‚ûï Add</button>
            </div>
        </div>
        <div class="wishlist-body">
            <div id="wishlist-content"></div>
        </div>
    </div>
</div>
<div id="sync-modal" class="modal">
    <div class="sync-modal-content">
        <div class="sync-header">
            <h2>üîÑ Sync</h2>
            <button class="close-sync-btn">&times;</button>
        </div>
        <div class="sync-body">
            <button id="run-sync-btn" class="run-sync-btn">
                ‚ñ∂Ô∏è Run Sync
            </button>
            <div id="sync-logs" class="sync-logs"></div>
        </div>
    </div>
</div>

<script>
    function openService(port) {
        const host = window.location.hostname;
        window.open(`http://${host}:${port}`, '_blank');
    }

    // Auto-replace spaces with dots as user types
    document.getElementById('movie').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            // Maintain cursor position after replacement
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    document.getElementById('extra').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            // Maintain cursor position after replacement
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    function setVals() {
        const movieInput = document.getElementById('movie');
        const movie = movieInput.value.trim();
        const extra = document.getElementById('extra').value;

        // Validate movie name is not empty
        if (!movie) {
            movieInput.classList.add('input-error');
            movieInput.focus();

            // Remove error class after user starts typing
            movieInput.addEventListener('input', function () {
                movieInput.classList.remove('input-error');
            }, {once: true});

            // Stop event propagation to prevent htmx from triggering
            event.stopPropagation();
            event.preventDefault();
            return false;
        }

        movieInput.classList.remove('input-error');

        const button = document.querySelector('button[hx-vals]');

        // Update the hx-vals attribute with current values
        button.setAttribute('hx-vals', JSON.stringify({
            movie: movie,
            extra: extra
        }));

        // Clear download message when starting new search
        document.getElementById('download-result-container').innerHTML = '';

        // Allow htmx to proceed
        return true;
    }

    // Add this to ensure htmx re-processes the button after updating hx-vals
    document.addEventListener('DOMContentLoaded', function () {
        const searchBtn = document.querySelector('.search-btn');

        // Use htmx:configRequest to dynamically set values right before request
        document.body.addEventListener('htmx:configRequest', function (evt) {
            if (evt.detail.elt === searchBtn) {
                const movie = document.getElementById('movie').value.trim();
                const extra = document.getElementById('extra').value;

                // Check if movie is empty and cancel the request
                if (!movie) {
                    evt.preventDefault();

                    const movieInput = document.getElementById('movie');
                    movieInput.classList.add('input-error');
                    movieInput.focus();

                    movieInput.addEventListener('input', function () {
                        movieInput.classList.remove('input-error');
                    }, {once: true});

                    return;
                }

                // Update the parameters with current values
                evt.detail.parameters.movie = movie;
                evt.detail.parameters.extra = extra;
            }
        });
    });


    let modalShowTime = 0;
    let pendingDownload = null;

    // Use event delegation to catch dynamically added buttons
    document.body.addEventListener('click', function (evt) {
        if (evt.target.classList.contains('download-btn')) {
            evt.preventDefault();
            evt.stopPropagation();

            // Store the download info from data attributes
            pendingDownload = {
                name: decodeURIComponent(evt.target.dataset.name),
                link: decodeURIComponent(evt.target.dataset.link)
            };

            // Show modal
            document.getElementById('download-modal').classList.add('show');
        }
    });

    // Handle confirm download
    document.getElementById('confirm-download').addEventListener('click', function () {
        if (pendingDownload) {
            const downloadLocation = document.getElementById('download-location').value;
            const downloadUrl = `/download-torrent?name=${encodeURIComponent(pendingDownload.name)}&link=${encodeURIComponent(pendingDownload.link)}&saveDir=${encodeURIComponent(downloadLocation)}`;

            // Hide form, show loading
            document.getElementById('download-modal').classList.remove('show');
            document.getElementById('preloader-modal').classList.add('show');

            // Record time when download starts
            modalShowTime = Date.now();

            // Make the request using htmx
            htmx.ajax('GET', downloadUrl, {
                target: '#download-result-container',
                swap: 'innerHTML'
            });
        }
    });

    // Handle cancel
    document.getElementById('cancel-download').addEventListener('click', function () {
        document.getElementById('download-modal').classList.remove('show');
        pendingDownload = null;
    });

    // Listen for htmx after-swap events
    document.body.addEventListener('htmx:afterSwap', function (evt) {
        // Scroll to search results
        if (evt.detail.target.id === 'search-results-container') {
            const resultsContainer = document.getElementById('search-results-container');
            if (resultsContainer && resultsContainer.innerHTML.trim() !== '') {
                resultsContainer.scrollIntoView({behavior: 'smooth', block: 'nearest'});
            }
        }

        // Hide modal after download completes
        if (evt.detail.target.id === 'download-result-container' && modalShowTime > 0) {
            const elapsedTime = Date.now() - modalShowTime;
            const remainingTime = Math.max(0, 1500 - elapsedTime);

            setTimeout(function () {
                document.getElementById('preloader-modal').classList.remove('show');
                pendingDownload = null;
                modalShowTime = 0;
            }, remainingTime);
        }
    });

    window.addEventListener('beforeunload', function() {
        if (activeEventSource) {
            activeEventSource.close();
            activeEventSource = null;
        }
    });

    // Wishlist modal handling
    document.getElementById('wishlist-btn').addEventListener('click', function () {
        loadWishlist();
    });

    function loadWishlist() {
        fetch('/get-wishlist')
            .then(response => response.json())
            .then(data => {
                const wishlistContent = document.getElementById('wishlist-content');

                if (data.length === 0) {
                    wishlistContent.innerHTML = '<div class="wishlist-empty">No items in wishlist</div>';
                } else {
                    let tableHtml = `
                    <table class="wishlist-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Name</th>
                                <th>Quality</th>
                                <th>Date Added</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                    data.forEach((item, index) => {
                        tableHtml += `
                        <tr>
                            <td class="wishlist-type">${item.type === 'm' ? 'üé¨ Movie' : 'üì∫ Series'}</td>
                            <td class="wishlist-name">${item.name}</td>
                            <td class="wishlist-quality">${item.quality}p</td>
                            <td class="wishlist-date">${item.dateAdded}</td>
                            <td class="wishlist-action">
                                <button class="delete-wishlist-btn" data-index="${index}" data-name="${item.name}">
                                    üóëÔ∏è
                                </button>
                            </td>
                        </tr>
                    `;
                    });

                    tableHtml += `
                        </tbody>
                    </table>
                `;

                    wishlistContent.innerHTML = tableHtml;

                    // Add event listeners to delete buttons
                    document.querySelectorAll('.delete-wishlist-btn').forEach(btn => {
                        btn.addEventListener('click', function () {
                            const index = this.dataset.index;
                            const name = this.dataset.name;

                            if (confirm(`Delete
                            "${name.replace(/\./g, ' ')}" from wishlist?`)) {
                                deleteWishlistItem(index);
                            }
                        });
                    });
                }

                document.getElementById('wishlist-modal').classList.add('show');
            })
            .catch(error => {
                document.getElementById('wishlist-content').innerHTML = '<div class="wishlist-error">Error loading wishlist</div>';
                document.getElementById('wishlist-modal').classList.add('show');
            });
    }

    function deleteWishlistItem(index) {
        fetch('/delete-wishlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({index: parseInt(index)})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reload the wishlist
                    loadWishlist();
                } else {
                    alert('Error deleting item from wishlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error deleting item from wishlist');
            });
    }

    // Close wishlist modal
    document.querySelector('.close-wishlist-btn').addEventListener('click', function () {
        document.getElementById('wishlist-modal').classList.remove('show');
    });

    // Close modal when clicking outside
    document.getElementById('wishlist-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('show');
        }
    });

    function addWishlistItem() {
        const type = document.getElementById('add-type').value;
        const name = document.getElementById('add-name').value.replace(/\s+/g, '.');
        const quality = document.getElementById('add-quality').value;

        if (!name.trim()) {
            alert('Please enter a movie/series name');
            return;
        }

        const newItem = {
            type: type,
            name: name,
            quality: quality
        };

        fetch('/add-wishlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(newItem)
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Clear the input fields
                    document.getElementById('add-name').value = '';
                    document.getElementById('add-quality').value = '1080';

                    // Reload the wishlist
                    loadWishlist();
                } else {
                    alert(data.message || 'Error adding item to wishlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error adding item to wishlist');
            });
    }

    // Add event listener for the add button
    document.getElementById('wishlist-btn').addEventListener('click', function () {
        loadWishlist();

        // Set up the add button listener when modal opens
        setTimeout(() => {
            const addBtn = document.getElementById('add-wishlist-btn');
            if (addBtn && !addBtn.hasListener) {
                addBtn.addEventListener('click', addWishlistItem);
                addBtn.hasListener = true;

                // Also add enter key support for the name input
                document.getElementById('add-name').addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        addWishlistItem();
                    }
                });
            }
        }, 100);
    });

    // Auto-replace spaces with dots in the add name field
    document.addEventListener('DOMContentLoaded', function () {
        const addNameInput = document.getElementById('add-name');
        if (addNameInput) {
            addNameInput.addEventListener('input', function (e) {
                const cursorPosition = e.target.selectionStart;
                const originalValue = e.target.value;
                const newValue = originalValue.replace(/\s+/g, '.');

                if (originalValue !== newValue) {
                    e.target.value = newValue;
                    const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
                    e.target.setSelectionRange(newCursorPosition, newCursorPosition);
                }
            });
        }
    });

    let syncLogsHistory = '';
    let syncStatus = null;
    let activeEventSource = null; // Track the active EventSource
    let isSyncRunning = false; // Track if sync is currently running

    // Sync modal handling
    document.getElementById('sync-btn').addEventListener('click', function () {
        document.getElementById('sync-modal').classList.add('show');
        const logsDiv = document.getElementById('sync-logs');

        // If sync is still running, just show current state
        if (isSyncRunning && activeEventSource) {
            // Continue showing the current logs with running status
            logsDiv.innerHTML = `
            <div class="sync-running">
                ‚è≥ Sync in progress...
            </div>
            <pre class="sync-log-content">${syncLogsHistory}</pre>
        `;

            // Auto-scroll to bottom
            const logContent = logsDiv.querySelector('.sync-log-content');
            if (logContent) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        } else if (syncLogsHistory) {
            // Show historical logs if not running
            const statusClass = syncStatus?.success ? 'sync-success' : 'sync-error';
            const statusIcon = syncStatus?.success ? '‚úÖ' : '‚ùå';
            const statusMessage = syncStatus ? `
            <div class="${statusClass}">
                ${statusIcon} Last sync ${syncStatus.success ? 'completed successfully' : 'failed'}${syncStatus.exitCode !== undefined ? ` (Exit code: ${syncStatus.exitCode})` : ''}
            </div>
        ` : '';

            logsDiv.innerHTML = `
            ${statusMessage}
            <pre class="sync-log-content">${syncLogsHistory}</pre>
        `;
        }
    });

    // Close sync modal
    document.querySelector('.close-sync-btn').addEventListener('click', function () {
        document.getElementById('sync-modal').classList.remove('show');
    });

    // Close modal when clicking outside
    document.getElementById('sync-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('show');
        }
    });

    document.getElementById('run-sync-btn').addEventListener('click', function () {
        const button = this;
        const logsDiv = document.getElementById('sync-logs');

        // If already running, don't start another
        if (isSyncRunning && activeEventSource) {
            return;
        }

        // Clear previous logs when starting new sync
        syncLogsHistory = '';
        syncStatus = null;
        isSyncRunning = true;

        // Close any existing EventSource
        if (activeEventSource) {
            activeEventSource.close();
            activeEventSource = null;
        }

        // Disable button and show loading state
        button.disabled = true;
        button.innerHTML = '‚è≥ Running...';
        logsDiv.innerHTML = '<div class="sync-loading">Starting sync process...</div>';

        // Store logs as they come in
        let allLogs = [];
        let hasErrors = false;

        // Create EventSource for real-time streaming
        activeEventSource = new EventSource('/run-sync-stream');

        activeEventSource.onmessage = function (event) {
            const data = JSON.parse(event.data);

            if (data.type === 'log' || data.type === 'error') {
                // Add log line to array
                allLogs.push(data.content);

                if (data.type === 'error') {
                    hasErrors = true;
                }

                // Update stored history
                syncLogsHistory = allLogs.join('\n');

                // Only update display if modal is visible
                if (document.getElementById('sync-modal').classList.contains('show')) {
                    logsDiv.innerHTML = `
                    <div class="sync-running">
                        ‚è≥ Sync in progress...
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;

                    // Auto-scroll to bottom
                    const logContent = logsDiv.querySelector('.sync-log-content');
                    if (logContent) {
                        logContent.scrollTop = logContent.scrollHeight;
                    }
                }
            } else if (data.type === 'complete') {
                // Process complete
                activeEventSource.close();
                activeEventSource = null;
                isSyncRunning = false;

                const success = data.exitCode === 0 && !hasErrors;

                // Store final logs and status
                syncLogsHistory = allLogs.join('\n') || 'No output';
                syncStatus = { success: success, exitCode: data.exitCode };

                const statusClass = success ? 'sync-success' : 'sync-error';
                const statusIcon = success ? '‚úÖ' : '‚ùå';

                // Only update display if modal is visible
                if (document.getElementById('sync-modal').classList.contains('show')) {
                    logsDiv.innerHTML = `
                    <div class="${statusClass}">
                        ${statusIcon} Sync ${success ? 'completed successfully' : 'failed'} (Exit code: ${data.exitCode})
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;
                }

                // Re-enable button
                button.disabled = false;
                button.innerHTML = '‚ñ∂Ô∏è Run Sync';
            }
        };

        activeEventSource.onerror = function (error) {
            console.error('EventSource error:', error);
            if (activeEventSource) {
                activeEventSource.close();
                activeEventSource = null;
            }
            isSyncRunning = false;

            // Store whatever logs we have
            syncLogsHistory = allLogs.join('\n');
            syncStatus = { success: false };

            // Only update display if modal is visible
            if (document.getElementById('sync-modal').classList.contains('show')) {
                // Show error if no logs were received
                if (allLogs.length === 0) {
                    logsDiv.innerHTML = `
                    <div class="sync-error">
                        ‚ùå Connection error: Unable to stream logs
                    </div>
                `;
                } else {
                    // Show what we have so far with error status
                    logsDiv.innerHTML = `
                    <div class="sync-error">
                        ‚ùå Sync interrupted
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;
                }
            }

            // Re-enable button
            button.disabled = false;
            button.innerHTML = '‚ñ∂Ô∏è Run Sync';
        };
    });

</script>
</body>
</html>
