<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shitflix Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/icons/favicon.png">
    <script src="https://unpkg.com/htmx.org"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="container">
    <h1>
        <img src="/icons/favicon.png" alt="Downloader icon"
             style="height: 1.2em;
             vertical-align: middle;
             margin-right: 0.2em;">
        Shitflix Dashboard
    </h1>

    <div class="service-buttons">
        <button onclick="openService(8096)" class="service-btn jellyfin-btn">
            üé¨ Jellyfin
        </button>
        <button onclick="openService(9091)" class="service-btn transmission-btn">
            ‚öôÔ∏è Transmission
        </button>
        <button id="wishlist-btn" class="service-btn wishlist-btn">
            üìù Wishlist
        </button>
        <button id="banlist-btn" class="service-btn banlist-btn">
            üö´ Banlist
        </button>
        <button id="sync-btn" class="service-btn sync-btn">
            üîÑ Sync
        </button>

    </div>

    <div class="search-form">
        <form onsubmit="return false;">
            <div class="form-group">
                <label for="movie">Movie Name</label>
                <input type="text" id="movie" name="movie" placeholder="Enter movie name..."/>
            </div>

            <div class="search-params-row">
                <div class="form-group half-width">
                    <label for="extra">Quality/Extra</label>
                    <input type="text" id="extra" name="extra" value="1080" placeholder="Quality, year, etc..."/>
                </div>
                <div class="form-group half-width">
                    <label for="codec">Codec</label>
                    <input type="text" id="codec" name="codec" placeholder="264, 265, etc..."/>
                </div>
            </div>

            <button class="search-btn"
                    hx-get="/get-search-results"
                    hx-trigger="click"
                    hx-swap="innerHTML"
                    hx-target="#search-results-container"
                    hx-indicator=".loading">
                üîç Search
            </button>
        </form>
    </div>

    <div id="download-result-container"></div>

    <div class="loading" style="display:none;">
        ‚è≥ Searching...
    </div>

    <div id="search-results-container">
        <!-- Results will be displayed here -->
    </div>
</div>

<div id="preloader-modal" class="modal">
    <div class="modal-content">
        <div class="modal-icon"></div>
    </div>
</div>

<div id="download-modal" class="modal">
    <div class="modal-content-dld">
        <div class="modal-form">
            <label for="download-location">Download Location:</label>
            <input type="text" id="download-location" value="/downloads/movies"/>
            <button id="confirm-download" class="confirm-btn">Start Download</button>
            <button id="cancel-download" class="cancel-btn">Cancel</button>
        </div>
    </div>
</div>
<div id="wishlist-modal" class="modal">
    <div class="wishlist-modal-content">
        <div class="wishlist-header">
            <h2>üìù Movie Wishlist</h2>
            <button class="close-wishlist-btn">&times;</button>
        </div>
        <div class="wishlist-description">
            <p><strong>About the Wishlist:</strong></p>
            <p>The wishlist is updated nightly and when running the sync action.</p>
            <p>It's recommended that you add the movie name followed by the year (Ex: The.Matrix.1999).</p>
            <p>Items are removed from the wishlist after downloading. </p>
            <p>Old items from the wishlist are automaticly cleared after a while. (Default 3 months)</p>
            <p class="wishlist-warning">‚ö†Ô∏è <strong>Warning:</strong>
                Keep you wishlists fairly small. (Max ~100 items) </p>
        </div>
        <div class="wishlist-add-section">
            <div class="add-form-row">
                <select id="add-type" class="add-input">
                    <option value="m">üé¨ Movie</option>
                    <option value="s">üì∫ Series</option>
                </select>
                <input type="text" id="add-name" class="add-input" placeholder="Movie.Name.Here">
                <input type="text" id="add-quality" class="add-input add-quality" placeholder="1080" value="1080">
                <button id="add-wishlist-btn" class="add-btn">‚ûï Add</button>
            </div>
        </div>
        <div class="wishlist-body">
            <div id="wishlist-content"></div>
        </div>
    </div>
</div>
<div id="banlist-modal" class="modal">
    <div class="banlist-modal-content">
        <div class="banlist-header">
            <h2>üö´ Media Banlist</h2>
            <button class="close-banlist-btn">&times;</button>
        </div>
        <div class="banlist-description">
            <p><strong>About the Banlist:</strong></p>
            <p>Media is automatically added to the banlist after it was downloaded.</p>
            <p>This prevents downloading the same item twice and helps with API spam.</p>
        </div>
        <div class="banlist-add-section">
            <div class="add-form-row">
                <select id="ban-type" class="add-input">
                    <option value="m">üé¨ Movie</option>
                    <option value="s">üì∫ Series</option>
                </select>
                <input type="text" id="ban-name" class="add-input" placeholder="Movie.Name.Here">
                <input type="text" id="ban-quality" class="add-input add-quality" placeholder="1080" value="1080">
                <button id="add-banlist-btn" class="add-btn">‚ûï Add</button>
            </div>
        </div>
        <div class="banlist-body">
            <div id="banlist-content"></div>
        </div>
    </div>
</div>
<div id="sync-modal" class="modal">
    <div class="sync-modal-content">
        <div class="sync-header">
            <h2>üîÑ Sync</h2>
            <button class="close-sync-btn">&times;</button>
        </div>
        <div class="sync-body">
            <div class="sync-description">
                <p><strong>About sync:</strong></p>
                <p>Sync action updates your wishlist with the latest trending media from TMDB.</p>
                <p>Then it processes the wishlist, and tries to download all of it.</p>
                <p>Basically it runs the automatic nightly sync, on demand.</p>
                <p class="sync-warning">‚ö†Ô∏è <strong>Warning:</strong> Do not abuse this... If you run this too often you
                    will get rate limited by Filelist & TMDB APIs.</p>
            </div>
            <button id="run-sync-btn" class="run-sync-btn">
                ‚ñ∂Ô∏è Run Sync
            </button>
            <div id="sync-logs" class="sync-logs"></div>
        </div>
    </div>
</div>

<script>
    function openService(port) {
        const host = window.location.hostname;
        window.open(`http://${host}:${port}`, '_blank');
    }

    // Auto-replace spaces with dots as user types
    document.getElementById('movie').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            // Maintain cursor position after replacement
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    document.getElementById('extra').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            // Maintain cursor position after replacement
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    document.getElementById('codec').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            // Maintain cursor position after replacement
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    function setVals() {
        const movieInput = document.getElementById('movie');
        const movie = movieInput.value.trim();
        const extra = document.getElementById('extra').value;

        // Validate movie name is not empty
        if (!movie) {
            movieInput.classList.add('input-error');
            movieInput.focus();

            // Remove error class after user starts typing
            movieInput.addEventListener('input', function () {
                movieInput.classList.remove('input-error');
            }, {once: true});

            // Stop event propagation to prevent htmx from triggering
            event.stopPropagation();
            event.preventDefault();
            return false;
        }

        movieInput.classList.remove('input-error');

        const button = document.querySelector('button[hx-vals]');

        // Update the hx-vals attribute with current values
        button.setAttribute('hx-vals', JSON.stringify({
            movie: movie,
            extra: extra
        }));

        // Clear download message when starting new search
        document.getElementById('download-result-container').innerHTML = '';

        // Allow htmx to proceed
        return true;
    }

    // Add this to ensure htmx re-processes the button after updating hx-vals
    document.addEventListener('DOMContentLoaded', function () {
        const searchBtn = document.querySelector('.search-btn');

        // Use htmx:configRequest to dynamically set values right before request
        document.body.addEventListener('htmx:configRequest', function (evt) {
            if (evt.detail.elt === searchBtn) {
                const movie = document.getElementById('movie').value.trim();
                const extra = document.getElementById('extra').value.trim();
                const codec = document.getElementById('codec').value.trim();

                // Check if movie is empty and cancel the request
                if (!movie) {
                    evt.preventDefault();

                    const movieInput = document.getElementById('movie');
                    movieInput.classList.add('input-error');
                    movieInput.focus();

                    movieInput.addEventListener('input', function () {
                        movieInput.classList.remove('input-error');
                    }, {once: true});

                    return;
                }

                // Update the parameters with current values
                evt.detail.parameters.movie = movie;
                evt.detail.parameters.extra = extra;
                evt.detail.parameters.codec = codec;
            }
        });
    });


    let modalShowTime = 0;
    let pendingDownload = null;

    // Use event delegation to catch dynamically added buttons
    document.body.addEventListener('click', function (evt) {
        if (evt.target.classList.contains('download-btn')) {
            evt.preventDefault();
            evt.stopPropagation();

            // Store the download info from data attributes
            pendingDownload = {
                name: decodeURIComponent(evt.target.dataset.name),
                link: decodeURIComponent(evt.target.dataset.link)
            };

            // Show modal
            document.getElementById('download-modal').classList.add('show');
        }
    });

    // Handle confirm download
    document.getElementById('confirm-download').addEventListener('click', function () {
        if (pendingDownload) {
            const downloadLocation = document.getElementById('download-location').value;
            const downloadUrl = `/download-torrent?name=${encodeURIComponent(pendingDownload.name)}&link=${encodeURIComponent(pendingDownload.link)}&saveDir=${encodeURIComponent(downloadLocation)}`;

            // Hide form, show loading
            document.getElementById('download-modal').classList.remove('show');
            document.getElementById('preloader-modal').classList.add('show');

            // Record time when download starts
            modalShowTime = Date.now();

            // Make the request using htmx
            htmx.ajax('GET', downloadUrl, {
                target: '#download-result-container',
                swap: 'innerHTML'
            });
        }
    });

    // Handle cancel
    document.getElementById('cancel-download').addEventListener('click', function () {
        document.getElementById('download-modal').classList.remove('show');
        pendingDownload = null;
    });

    // Listen for htmx after-swap events
    document.body.addEventListener('htmx:afterSwap', function (evt) {
        // Scroll to search results
        if (evt.detail.target.id === 'search-results-container') {
            const resultsContainer = document.getElementById('search-results-container');
            if (resultsContainer && resultsContainer.innerHTML.trim() !== '') {
                resultsContainer.scrollIntoView({behavior: 'smooth', block: 'nearest'});
            }
        }

        // Hide modal after download completes
        if (evt.detail.target.id === 'download-result-container' && modalShowTime > 0) {
            const elapsedTime = Date.now() - modalShowTime;
            const remainingTime = Math.max(0, 1500 - elapsedTime);

            setTimeout(function () {
                document.getElementById('preloader-modal').classList.remove('show');
                pendingDownload = null;
                modalShowTime = 0;
                document.querySelector('.service-buttons').scrollIntoView({behavior: 'smooth', block: 'start'});
            }, remainingTime);
        }
    });

    window.addEventListener('beforeunload', function () {
        if (activeEventSource) {
            activeEventSource.close();
            activeEventSource = null;
        }
    });

    // Wishlist modal handling
    document.getElementById('wishlist-btn').addEventListener('click', function () {
        loadWishlist();
    });

    function loadWishlist() {
        fetch('/get-wishlist')
            .then(response => response.json())
            .then(data => {
                document.querySelector('.wishlist-header h2').innerHTML = `üìù Movie Wishlist <span class="list-count">(${data.length})</span>`;

                const wishlistContent = document.getElementById('wishlist-content');

                if (data.length === 0) {
                    wishlistContent.innerHTML = '<div class="wishlist-empty">No items in wishlist</div>';
                } else {
                    let tableHtml = `
                    <table class="wishlist-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Name</th>
                                <th>Quality</th>
                                <th>Date Added</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                    data.forEach((item, index) => {
                        tableHtml += `
                        <tr>
                            <td class="wishlist-type">${item.type === 'm' ? 'üé¨ Movie' : 'üì∫ Series'}</td>
                            <td class="wishlist-name">${item.name}</td>
                            <td class="wishlist-quality">${item.quality}p</td>
                            <td class="wishlist-date">${item.dateAdded}</td>
                            <td class="wishlist-action">
                                <button class="delete-wishlist-btn" data-index="${index}" data-name="${item.name}">
                                    üóëÔ∏è
                                </button>
                            </td>
                        </tr>
                    `;
                    });

                    tableHtml += `
                        </tbody>
                    </table>
                `;

                    wishlistContent.innerHTML = tableHtml;

                    // Add event listeners to delete buttons
                    document.querySelectorAll('.delete-wishlist-btn').forEach(btn => {
                        btn.addEventListener('click', function () {
                            const index = this.dataset.index;
                            const name = this.dataset.name;

                            if (confirm(`Delete
                            "${name.replace(/\./g, ' ')}" from wishlist?`)) {
                                deleteWishlistItem(index);
                            }
                        });
                    });
                }

                document.getElementById('wishlist-modal').classList.add('show');
            })
            .catch(error => {
                document.getElementById('wishlist-content').innerHTML = '<div class="wishlist-error">Error loading wishlist</div>';
                document.getElementById('wishlist-modal').classList.add('show');
            });
    }

    function deleteWishlistItem(index) {
        fetch('/delete-wishlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({index: parseInt(index)})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reload the wishlist
                    loadWishlist();
                } else {
                    alert('Error deleting item from wishlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error deleting item from wishlist');
            });
    }

    // Close wishlist modal
    document.querySelector('.close-wishlist-btn').addEventListener('click', function () {
        document.getElementById('wishlist-modal').classList.remove('show');
    });

    // Close modal when clicking outside
    document.getElementById('wishlist-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('show');
        }
    });

    function addWishlistItem() {
        const type = document.getElementById('add-type').value;
        const name = document.getElementById('add-name').value.replace(/\s+/g, '.');
        const quality = document.getElementById('add-quality').value;

        if (!name.trim()) {
            alert('Please enter a movie/series name');
            return;
        }

        const newItem = {
            type: type,
            name: name,
            quality: quality
        };

        fetch('/add-wishlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(newItem)
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Clear the input fields
                    document.getElementById('add-name').value = '';
                    document.getElementById('add-quality').value = '1080';

                    // Reload the wishlist
                    loadWishlist();
                    setTimeout(function () {
                        document.querySelector('#wishlist-content').scrollIntoView({behavior: 'smooth', block: 'end'});
                    }, 100);
                } else {
                    alert(data.message || 'Error adding item to wishlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error adding item to wishlist');
            });
    }

    // Add event listener for the add button
    document.getElementById('wishlist-btn').addEventListener('click', function () {
        loadWishlist();

        // Set up the add button listener when modal opens
        setTimeout(() => {
            const addBtn = document.getElementById('add-wishlist-btn');
            if (addBtn && !addBtn.hasListener) {
                addBtn.addEventListener('click', addWishlistItem);
                addBtn.hasListener = true;

                // Also add enter key support for the name input
                document.getElementById('add-name').addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        addWishlistItem();
                    }
                });
            }
        }, 100);
    });

    // Auto-replace spaces with dots in the add name field
    document.addEventListener('DOMContentLoaded', function () {
        const addNameInput = document.getElementById('add-name');
        if (addNameInput) {
            addNameInput.addEventListener('input', function (e) {
                const cursorPosition = e.target.selectionStart;
                const originalValue = e.target.value;
                const newValue = originalValue.replace(/\s+/g, '.');

                if (originalValue !== newValue) {
                    e.target.value = newValue;
                    const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
                    e.target.setSelectionRange(newCursorPosition, newCursorPosition);
                }
            });
        }
    });

    let syncLogsHistory = '';
    let syncStatus = null;
    let activeEventSource = null; // Track the active EventSource
    let isSyncRunning = false; // Track if sync is currently running

    // Sync modal handling
    document.getElementById('sync-btn').addEventListener('click', function () {
        document.getElementById('sync-modal').classList.add('show');
        const logsDiv = document.getElementById('sync-logs');

        // If sync is still running, just show current state
        if (isSyncRunning && activeEventSource) {
            // Continue showing the current logs with running status
            logsDiv.innerHTML = `
            <div class="sync-running">
                ‚è≥ Sync in progress...
            </div>
            <pre class="sync-log-content">${syncLogsHistory}</pre>
        `;

            // Auto-scroll to bottom
            const logContent = logsDiv.querySelector('.sync-log-content');
            if (logContent) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        } else if (syncLogsHistory) {
            // Show historical logs if not running
            const statusClass = syncStatus?.success ? 'sync-success' : 'sync-error';
            const statusIcon = syncStatus?.success ? '‚úÖ' : '‚ùå';
            const statusMessage = syncStatus ? `
            <div class="${statusClass}">
                ${statusIcon} Last sync ${syncStatus.success ? 'completed successfully' : 'failed'}${syncStatus.exitCode !== undefined ? ` (Exit code: ${syncStatus.exitCode})` : ''}
            </div>
        ` : '';

            logsDiv.innerHTML = `
            ${statusMessage}
            <pre class="sync-log-content">${syncLogsHistory}</pre>
        `;
        }
    });

    // Close sync modal
    document.querySelector('.close-sync-btn').addEventListener('click', function () {
        document.getElementById('sync-modal').classList.remove('show');
    });

    // Close modal when clicking outside
    document.getElementById('sync-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('show');
        }
    });

    document.getElementById('run-sync-btn').addEventListener('click', function () {
        const button = this;
        const logsDiv = document.getElementById('sync-logs');

        // If already running, don't start another
        if (isSyncRunning && activeEventSource) {
            return;
        }

        // Clear previous logs when starting new sync
        syncLogsHistory = '';
        syncStatus = null;
        isSyncRunning = true;

        // Close any existing EventSource
        if (activeEventSource) {
            activeEventSource.close();
            activeEventSource = null;
        }

        // Disable button and show loading state
        button.disabled = true;
        button.innerHTML = '‚è≥ Running...';
        logsDiv.innerHTML = '<div class="sync-loading">Starting sync process...</div>';

        // Store logs as they come in
        let allLogs = [];
        let hasErrors = false;

        // Create EventSource for real-time streaming
        activeEventSource = new EventSource('/run-sync-stream');

        activeEventSource.onmessage = function (event) {
            const data = JSON.parse(event.data);

            if (data.type === 'log' || data.type === 'error') {
                // Add log line to array
                allLogs.push(data.content);

                if (data.type === 'error') {
                    hasErrors = true;
                }

                // Update stored history
                syncLogsHistory = allLogs.join('\n');

                // Only update display if modal is visible
                if (document.getElementById('sync-modal').classList.contains('show')) {
                    logsDiv.innerHTML = `
                    <div class="sync-running">
                        ‚è≥ Sync in progress...
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;

                    // Auto-scroll to bottom
                    const logContent = logsDiv.querySelector('.sync-log-content');
                    if (logContent) {
                        logContent.scrollTop = logContent.scrollHeight;
                    }
                }
            } else if (data.type === 'complete') {
                // Process complete
                activeEventSource.close();
                activeEventSource = null;
                isSyncRunning = false;

                const success = data.exitCode === 0 && !hasErrors;

                // Store final logs and status
                syncLogsHistory = allLogs.join('\n') || 'No output';
                syncStatus = {success: success, exitCode: data.exitCode};

                const statusClass = success ? 'sync-success' : 'sync-error';
                const statusIcon = success ? '‚úÖ' : '‚ùå';

                // Only update display if modal is visible
                if (document.getElementById('sync-modal').classList.contains('show')) {
                    logsDiv.innerHTML = `
                    <div class="${statusClass}">
                        ${statusIcon} Sync ${success ? 'completed successfully' : 'failed'} (Exit code: ${data.exitCode})
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;
                }

                // Re-enable button
                button.disabled = false;
                button.innerHTML = '‚ñ∂Ô∏è Run Sync';
            }
        };

        activeEventSource.onerror = function (error) {
            console.error('EventSource error:', error);
            if (activeEventSource) {
                activeEventSource.close();
                activeEventSource = null;
            }
            isSyncRunning = false;

            // Store whatever logs we have
            syncLogsHistory = allLogs.join('\n');
            syncStatus = {success: false};

            // Only update display if modal is visible
            if (document.getElementById('sync-modal').classList.contains('show')) {
                // Show error if no logs were received
                if (allLogs.length === 0) {
                    logsDiv.innerHTML = `
                    <div class="sync-error">
                        ‚ùå Connection error: Unable to stream logs
                    </div>
                `;
                } else {
                    // Show what we have so far with error status
                    logsDiv.innerHTML = `
                    <div class="sync-error">
                        ‚ùå Sync interrupted
                    </div>
                    <pre class="sync-log-content">${syncLogsHistory}</pre>
                `;
                }
            }

            // Re-enable button
            button.disabled = false;
            button.innerHTML = '‚ñ∂Ô∏è Run Sync';
        };
    });

    // Add this JavaScript code after the wishlist handlers

    // Banlist modal handling
    document.getElementById('banlist-btn').addEventListener('click', function () {
        loadBanlist();
    });

    function loadBanlist() {
        fetch('/get-banlist')
            .then(response => response.json())
            .then(data => {
                document.querySelector('.banlist-header h2').innerHTML = `üö´ Media Banlist <span class="list-count">(${data.length})</span>`;

                const banlistContent = document.getElementById('banlist-content');

                if (data.length === 0) {
                    banlistContent.innerHTML = '<div class="banlist-empty">No items in banlist</div>';
                } else {
                    let tableHtml = `
                    <table class="banlist-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Name</th>
                                <th>Quality</th>
                                <th>Date Added</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                    data.forEach((item, index) => {
                        tableHtml += `
                        <tr>
                            <td class="banlist-type">${item.type === 'm' ? 'üé¨ Movie' : 'üì∫ Series'}</td>
                            <td class="banlist-name">${item.name}</td>
                            <td class="banlist-quality">${item.quality}p</td>
                            <td class="banlist-date">${item.dateAdded}</td>
                            <td class="banlist-action">
                                <button class="delete-banlist-btn" data-index="${index}" data-name="${item.name}">
                                    üóëÔ∏è
                                </button>
                            </td>
                        </tr>
                    `;
                    });

                    tableHtml += `
                        </tbody>
                    </table>
                `;

                    banlistContent.innerHTML = tableHtml;

                    // Add event listeners to delete buttons
                    document.querySelectorAll('.delete-banlist-btn').forEach(btn => {
                        btn.addEventListener('click', function () {
                            const index = this.dataset.index;
                            const name = this.dataset.name;

                            if (confirm(`Remove "${name.replace(/\./g, ' ')}" from banlist?`)) {
                                deleteBanlistItem(index);
                            }
                        });
                    });
                }

                document.getElementById('banlist-modal').classList.add('show');
            })
            .catch(error => {
                document.getElementById('banlist-content').innerHTML = '<div class="banlist-error">Error loading banlist</div>';
                document.getElementById('banlist-modal').classList.add('show');
            });
    }

    function deleteBanlistItem(index) {
        fetch('/delete-banlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({index: parseInt(index)})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reload the banlist
                    loadBanlist();
                } else {
                    alert('Error deleting item from banlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error deleting item from banlist');
            });
    }

    function addBanlistItem() {
        const type = document.getElementById('ban-type').value;
        const name = document.getElementById('ban-name').value.replace(/\s+/g, '.');
        const quality = document.getElementById('ban-quality').value;

        if (!name.trim()) {
            alert('Please enter a movie/series name');
            return;
        }

        const newItem = {
            type: type,
            name: name,
            quality: quality
        };

        fetch('/add-banlist-item', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(newItem)
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Clear the input fields
                    document.getElementById('ban-name').value = '';
                    document.getElementById('ban-quality').value = '1080';

                    // Reload the banlist
                    loadBanlist();
                    setTimeout(function () {
                        document.querySelector('#banlist-content').scrollIntoView({behavior: 'smooth', block: 'end'});
                    }, 100);
                } else {
                    alert(data.message || 'Error adding item to banlist');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error adding item to banlist');
            });
    }

    // Set up event listeners
    document.querySelector('.close-banlist-btn').addEventListener('click', function () {
        document.getElementById('banlist-modal').classList.remove('show');
    });

    document.getElementById('banlist-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('show');
        }
    });

    document.getElementById('add-banlist-btn').addEventListener('click', addBanlistItem);

    // Auto-replace spaces with dots in the ban name field
    document.getElementById('ban-name').addEventListener('input', function (e) {
        const cursorPosition = e.target.selectionStart;
        const originalValue = e.target.value;
        const newValue = originalValue.replace(/\s+/g, '.');

        if (originalValue !== newValue) {
            e.target.value = newValue;
            const newCursorPosition = cursorPosition - (originalValue.length - newValue.length);
            e.target.setSelectionRange(newCursorPosition, newCursorPosition);
        }
    });

    // Add enter key support for the ban name input
    document.getElementById('ban-name').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
            addBanlistItem();
        }
    });
    // Add ESC key handler to close modals
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
            // Close wishlist modal if open
            const wishlistModal = document.getElementById('wishlist-modal');
            if (wishlistModal.classList.contains('show')) {
                wishlistModal.classList.remove('show');
            }

            // Close banlist modal if open
            const banlistModal = document.getElementById('banlist-modal');
            if (banlistModal.classList.contains('show')) {
                banlistModal.classList.remove('show');
            }

            // Close sync modal if open
            const syncModal = document.getElementById('sync-modal');
            if (syncModal.classList.contains('show')) {
                syncModal.classList.remove('show');
            }

            // Also close download modal if open
            const downloadModal = document.getElementById('download-modal');
            if (downloadModal.classList.contains('show')) {
                downloadModal.classList.remove('show');
                pendingDownload = null;
            }
        }
    });
    document.body.addEventListener('touchstart', function (e) {
        if (e.target.classList.contains('movie-name')) {
            const rect = e.target.getBoundingClientRect();
            const tooltip = document.createElement('div');
            tooltip.textContent = e.target.textContent;
            tooltip.style.position = 'absolute';
            tooltip.style.background = '#a855f7';
            tooltip.style.color = '#fff';
            tooltip.style.padding = '8px 16px';
            tooltip.style.borderRadius = '6px';
            tooltip.style.zIndex = 9999;
            tooltip.style.maxWidth = '90vw';
            tooltip.style.wordBreak = 'break-word';
            tooltip.style.textAlign = 'center';

            // Calculate initial position
            let left = rect.left + window.scrollX + rect.width / 2;
            let top = rect.top + window.scrollY - 10;

            // Temporarily add to body to measure width
            tooltip.style.visibility = 'hidden';
            document.body.appendChild(tooltip);
            const tooltipRect = tooltip.getBoundingClientRect();

            // Adjust if overflowing left/right
            let adjustedLeft = left;
            if (tooltipRect.width > window.innerWidth) {
                tooltip.style.width = '90vw';
            }
            if (left - tooltipRect.width / 2 < 0) {
                adjustedLeft = tooltipRect.width / 2 + 8;
            } else if (left + tooltipRect.width / 2 > window.innerWidth) {
                adjustedLeft = window.innerWidth - tooltipRect.width / 2 - 8;
            }
            tooltip.style.left = `${adjustedLeft}px`;
            tooltip.style.top = `${top}px`;
            tooltip.style.transform = 'translate(-50%, -100%)';
            tooltip.style.visibility = 'visible';

            setTimeout(() => {
                tooltip.remove();
            }, 2500);
        }
    });
</script>
</body>
</html>
